    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>tests.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
                </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='tests_rb.html'>tests.rb</a>
          </td>
          <td class='lines_total'>
            <tt>836</tt>
          </td>
          <td class='lines_code'>
            <tt>634</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>96.9%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='97' />
                      <td class='uncovered' width='3' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>95.9%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='96' />
                      <td class='uncovered' width='4' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="inferred0"><a name="line1" />  1 #!/usr/bin/env ruby
</span><span class="marked1"><a name="line2" />  2 require 'test/unit'
</span><span class="marked0"><a name="line3" />  3 require 'magic_xml'
</span><span class="inferred1"><a name="line4" />  4 
</span><span class="inferred0"><a name="line5" />  5 # For tests
</span><span class="marked1"><a name="line6" />  6 require 'stringio'
</span><span class="inferred0"><a name="line7" />  7 
</span><span class="marked1"><a name="line8" />  8 class XML_Tests &lt; Test::Unit::TestCase
</span><span class="inferred0"><a name="line9" />  9     # Test whether XML.new constructors work (without monadic case)
</span><span class="marked1"><a name="line10" /> 10     def test_constructors
</span><span class="marked0"><a name="line11" /> 11         br = XML.new(:br)
</span><span class="marked1"><a name="line12" /> 12         h3 = XML.new(:h3, &quot;Hello&quot;)
</span><span class="marked0"><a name="line13" /> 13         a  = XML.new(:a, {:href =&gt; &quot;http://www.google.com/&quot;}, &quot;Google&quot;)
</span><span class="marked1"><a name="line14" /> 14         ul = XML.new(:ul, XML.new(:li, &quot;Hello&quot;), XML.new(:li, &quot;world&quot;))
</span><span class="inferred0"><a name="line15" /> 15 
</span><span class="marked1"><a name="line16" /> 16         assert_equal(&quot;&lt;br/&gt;&quot;, br.to_s, &quot;Constructors should work&quot;)
</span><span class="marked0"><a name="line17" /> 17         assert_equal(&quot;&lt;h3&gt;Hello&lt;/h3&gt;&quot;, h3.to_s, &quot;Constructors should work&quot;)
</span><span class="marked1"><a name="line18" /> 18         assert_equal(&quot;&lt;a href='http://www.google.com/'&gt;Google&lt;/a&gt;&quot;, a.to_s, &quot;Constructors should work&quot;)
</span><span class="marked0"><a name="line19" /> 19         assert_equal(&quot;&lt;ul&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;li&gt;world&lt;/li&gt;&lt;/ul&gt;&quot;, ul.to_s, &quot;Constructors should work&quot;)
</span><span class="inferred1"><a name="line20" /> 20     end
</span><span class="inferred0"><a name="line21" /> 21 
</span><span class="inferred1"><a name="line22" /> 22     # Test character escaping on output, in text and in attribute values
</span><span class="marked0"><a name="line23" /> 23     def test_escapes
</span><span class="marked1"><a name="line24" /> 24         p = XML.new(:p, &quot;&lt; &gt; &amp;&quot;)
</span><span class="marked0"><a name="line25" /> 25         foo = XML.new(:foo, {:bar=&gt;&quot;&lt; &gt; ' \&quot; &amp;&quot;})
</span><span class="inferred1"><a name="line26" /> 26 
</span><span class="marked0"><a name="line27" /> 27         assert_equal(&quot;&lt;p&gt;&amp;lt; &amp;gt; &amp;amp;&lt;/p&gt;&quot;, p.to_s, &quot;Character escaping should work&quot;)
</span><span class="marked1"><a name="line28" /> 28         assert_equal(&quot;&lt;foo bar='&amp;lt; &amp;gt; &amp;apos; &amp;quot; &amp;amp;'/&gt;&quot;, foo.to_s, &quot;Character escaping in attributes should work&quot;)
</span><span class="inferred0"><a name="line29" /> 29     end
</span><span class="inferred1"><a name="line30" /> 30 
</span><span class="inferred0"><a name="line31" /> 31     # Test #sort_by and #children_sort_by
</span><span class="marked1"><a name="line32" /> 32     def test_sort_by
</span><span class="marked0"><a name="line33" /> 33         doc = XML.parse(&quot;&lt;foo&gt;&lt;bar id='5'/&gt;a&lt;bar id='3'/&gt;c&lt;bar id='4'/&gt;b&lt;bar id='1'/&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred1"><a name="line34" /> 34         
</span><span class="marked0"><a name="line35" /> 35         doc_by_id = doc.sort_by{|c| c[:id]}
</span><span class="marked1"><a name="line36" /> 36         assert_equal(&quot;&lt;foo&gt;&lt;bar id='1'/&gt;&lt;bar id='3'/&gt;&lt;bar id='4'/&gt;&lt;bar id='5'/&gt;&lt;/foo&gt;&quot;, doc_by_id.to_s)
</span><span class="inferred0"><a name="line37" /> 37 
</span><span class="marked1"><a name="line38" /> 38         doc_all_by_id = doc.children_sort_by{|c| if c.is_a? XML then [0, c[:id]] else [1, c] end}
</span><span class="marked0"><a name="line39" /> 39         assert_equal(&quot;&lt;foo&gt;&lt;bar id='1'/&gt;&lt;bar id='3'/&gt;&lt;bar id='4'/&gt;&lt;bar id='5'/&gt;abc&lt;/foo&gt;&quot;, doc_all_by_id.to_s)
</span><span class="inferred1"><a name="line40" /> 40     end
</span><span class="inferred0"><a name="line41" /> 41 
</span><span class="inferred1"><a name="line42" /> 42     # Test XML#[] and XML#[]= for attribute access
</span><span class="marked0"><a name="line43" /> 43     def test_attr
</span><span class="marked1"><a name="line44" /> 44         foo = XML.new(:foo, {:x =&gt; &quot;1&quot;})
</span><span class="marked0"><a name="line45" /> 45         assert_equal(&quot;1&quot;, foo[:x], &quot;Attribute reading should work&quot;)
</span><span class="marked1"><a name="line46" /> 46         foo[:x] = &quot;2&quot;
</span><span class="marked0"><a name="line47" /> 47         foo[:y] = &quot;3&quot;
</span><span class="marked1"><a name="line48" /> 48         assert_equal(&quot;2&quot;, foo[:x], &quot;Attribute writing should work&quot;)
</span><span class="marked0"><a name="line49" /> 49         assert_equal(&quot;3&quot;, foo[:y], &quot;Attribute writing should work&quot;)
</span><span class="inferred1"><a name="line50" /> 50     end
</span><span class="inferred0"><a name="line51" /> 51    
</span><span class="inferred1"><a name="line52" /> 52     # Test XML#&lt;&lt; method for adding children
</span><span class="marked0"><a name="line53" /> 53     def test_add
</span><span class="marked1"><a name="line54" /> 54         a = XML.new(:p, &quot;Hello&quot;)
</span><span class="marked0"><a name="line55" /> 55         a &lt;&lt; &quot;, &quot;
</span><span class="marked1"><a name="line56" /> 56         a &lt;&lt; &quot;world!&quot;
</span><span class="marked0"><a name="line57" /> 57         assert_equal(&quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;, a.to_s, &quot;XML#&lt;&lt; should work&quot;)
</span><span class="inferred1"><a name="line58" /> 58 
</span><span class="marked0"><a name="line59" /> 59         b = XML.new(:foo)
</span><span class="marked1"><a name="line60" /> 60         b &lt;&lt; XML.new(:bar)
</span><span class="marked0"><a name="line61" /> 61         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;, b.to_s, &quot;XML#&lt;&lt; should work&quot;)
</span><span class="inferred1"><a name="line62" /> 62     end
</span><span class="inferred0"><a name="line63" /> 63    
</span><span class="inferred1"><a name="line64" /> 64     # Test XML#each method for iterating over children
</span><span class="marked0"><a name="line65" /> 65     def test_each
</span><span class="marked1"><a name="line66" /> 66         a = XML.new(:p, &quot;Hello&quot;, &quot;, &quot;, &quot;world&quot;, XML.new(:br))
</span><span class="marked0"><a name="line67" /> 67         b = &quot;&quot;
</span><span class="marked1"><a name="line68" /> 68         a.each{|c| b += c.to_s}
</span><span class="marked0"><a name="line69" /> 69         assert_equal(&quot;Hello, world&lt;br/&gt;&quot;, b, &quot;XML#each should work&quot;)
</span><span class="inferred1"><a name="line70" /> 70     end
</span><span class="inferred0"><a name="line71" /> 71 
</span><span class="inferred1"><a name="line72" /> 72     # Test XML#map method
</span><span class="marked0"><a name="line73" /> 73     def test_map
</span><span class="marked1"><a name="line74" /> 74         a = XML.new(:body, XML.new(:h3, &quot;One&quot;), &quot;Hello&quot;, XML.new(:h3, &quot;Two&quot;))
</span><span class="marked0"><a name="line75" /> 75         b = a.map{|c|
</span><span class="marked1"><a name="line76" /> 76             if c.is_a? XML and c.name == :h3
</span><span class="marked0"><a name="line77" /> 77                 XML.new(:h2, c.attrs, *c.contents)
</span><span class="inferred1"><a name="line78" /> 78             else
</span><span class="marked0"><a name="line79" /> 79                 c
</span><span class="inferred1"><a name="line80" /> 80             end
</span><span class="inferred0"><a name="line81" /> 81         }
</span><span class="marked1"><a name="line82" /> 82         assert_equal(&quot;&lt;body&gt;&lt;h3&gt;One&lt;/h3&gt;Hello&lt;h3&gt;Two&lt;/h3&gt;&lt;/body&gt;&quot;, a.to_s, &quot;XML#map should not modify the argument&quot;)
</span><span class="marked0"><a name="line83" /> 83         assert_equal(&quot;&lt;body&gt;&lt;h2&gt;One&lt;/h2&gt;Hello&lt;h2&gt;Two&lt;/h2&gt;&lt;/body&gt;&quot;, b.to_s, &quot;XML#map should work&quot;)
</span><span class="inferred1"><a name="line84" /> 84         
</span><span class="marked0"><a name="line85" /> 85         d = a.map(:h3) {|c|
</span><span class="marked1"><a name="line86" /> 86             XML.new(:h2, c.attrs, *c.contents)
</span><span class="inferred0"><a name="line87" /> 87         }
</span><span class="marked1"><a name="line88" /> 88         assert_equal(&quot;&lt;body&gt;&lt;h2&gt;One&lt;/h2&gt;Hello&lt;h2&gt;Two&lt;/h2&gt;&lt;/body&gt;&quot;, d.to_s, &quot;XML#map should accept selectors&quot;)
</span><span class="inferred0"><a name="line89" /> 89     end
</span><span class="inferred1"><a name="line90" /> 90  
</span><span class="inferred0"><a name="line91" /> 91     # Test XML#==  
</span><span class="marked1"><a name="line92" /> 92     def test_eqeq
</span><span class="marked0"><a name="line93" /> 93         a = XML.new(:foo)
</span><span class="marked1"><a name="line94" /> 94         b = XML.new(:foo)
</span><span class="marked0"><a name="line95" /> 95         c = XML.new(:bar)
</span><span class="marked1"><a name="line96" /> 96         assert(a==a, &quot;XML#== should work&quot;)
</span><span class="marked0"><a name="line97" /> 97         assert(a==b, &quot;XML#== should work&quot;)
</span><span class="marked1"><a name="line98" /> 98         assert(a!=c, &quot;XML#== should work&quot;)
</span><span class="inferred0"><a name="line99" /> 99        
</span><span class="marked1"><a name="line100" />100         d = XML.new(:foo, {:bar =&gt; &quot;1&quot;})
</span><span class="marked0"><a name="line101" />101         e = XML.new(:foo, {:bar =&gt; &quot;1&quot;})
</span><span class="marked1"><a name="line102" />102         f = XML.new(:foo, {:bar =&gt; &quot;2&quot;})
</span><span class="marked0"><a name="line103" />103         assert(d==d, &quot;XML#== should work&quot;)
</span><span class="marked1"><a name="line104" />104         assert(d==e, &quot;XML#== should work&quot;)
</span><span class="marked0"><a name="line105" />105         assert(d!=f, &quot;XML#== should work&quot;)
</span><span class="inferred1"><a name="line106" />106        
</span><span class="marked0"><a name="line107" />107         a = XML.new(:foo, &quot;Hello, world!&quot;)
</span><span class="marked1"><a name="line108" />108         b = XML.new(:foo, &quot;Hello, world!&quot;)
</span><span class="marked0"><a name="line109" />109         c = XML.new(:foo, &quot;Hello&quot;, &quot;, world!&quot;)
</span><span class="marked1"><a name="line110" />110         d = XML.new(:foo, &quot;Hello&quot;)
</span><span class="marked0"><a name="line111" />111         e = XML.new(:foo, &quot;Hello&quot;, &quot;&quot;)
</span><span class="marked1"><a name="line112" />112         assert(a==a, &quot;XML#== should work&quot;)
</span><span class="marked0"><a name="line113" />113         assert(a==b, &quot;XML#== should work&quot;)
</span><span class="marked1"><a name="line114" />114         assert(a==c, &quot;XML#== should work&quot;)
</span><span class="marked0"><a name="line115" />115         assert(a!=d, &quot;XML#== should work&quot;)
</span><span class="marked1"><a name="line116" />116         assert(d==e, &quot;Empty children should not affect XML#==&quot;)
</span><span class="inferred0"><a name="line117" />117        
</span><span class="inferred1"><a name="line118" />118         # Highly pathological case
</span><span class="marked0"><a name="line119" />119         a = XML.new(:foo, &quot;ab&quot;, &quot;cde&quot;, &quot;&quot;, &quot;fg&quot;, &quot;hijk&quot;, &quot;&quot;, &quot;&quot;)
</span><span class="marked1"><a name="line120" />120         b = XML.new(:foo, &quot;&quot;, &quot;abc&quot;, &quot;d&quot;, &quot;efg&quot;, &quot;h&quot;, &quot;ijk&quot;)
</span><span class="marked0"><a name="line121" />121         assert(a==b, &quot;XML#== should work with differently split Strings too&quot;)
</span><span class="inferred1"><a name="line122" />122         
</span><span class="inferred0"><a name="line123" />123         # String vs XML
</span><span class="marked1"><a name="line124" />124         a = XML.new(:foo, &quot;Hello&quot;)
</span><span class="marked0"><a name="line125" />125         b = XML.new(:foo) {foo!}
</span><span class="marked1"><a name="line126" />126         c = XML.new(:foo) {bar!}
</span><span class="marked0"><a name="line127" />127         assert(a!=b, &quot;XML#== should work with children of different types&quot;)
</span><span class="marked1"><a name="line128" />128         assert(b!=c, &quot;XML#== should work recursively&quot;)
</span><span class="inferred0"><a name="line129" />129 
</span><span class="marked1"><a name="line130" />130         a = XML.new(:foo) {foo!; bar!}
</span><span class="marked0"><a name="line131" />131         b = XML.new(:foo) {foo!; foo!}
</span><span class="marked1"><a name="line132" />132         assert(a!=b, &quot;XML#== should work recursively&quot;)
</span><span class="inferred0"><a name="line133" />133     end
</span><span class="inferred1"><a name="line134" />134    
</span><span class="inferred0"><a name="line135" />135     # Test dup-with-block method
</span><span class="marked1"><a name="line136" />136     def test_dup
</span><span class="marked0"><a name="line137" />137         a = XML.new(:foo, {:a =&gt; &quot;1&quot;}, &quot;Hello&quot;)
</span><span class="marked1"><a name="line138" />138         b = a.dup{ @name = :bar }
</span><span class="marked0"><a name="line139" />139         c = a.dup{ self[:a] = &quot;2&quot; }
</span><span class="marked1"><a name="line140" />140         d = a.dup{ self &lt;&lt; &quot;, world!&quot; }
</span><span class="inferred0"><a name="line141" />141        
</span><span class="marked1"><a name="line142" />142         assert_equal(&quot;&lt;foo a='1'&gt;Hello&lt;/foo&gt;&quot;, a.to_s, &quot;XML#dup{} should not modify its argument&quot;)
</span><span class="marked0"><a name="line143" />143         assert_equal(&quot;&lt;bar a='1'&gt;Hello&lt;/bar&gt;&quot;, b.to_s, &quot;XML#dup{} should work&quot;)
</span><span class="marked1"><a name="line144" />144         assert_equal(&quot;&lt;foo a='2'&gt;Hello&lt;/foo&gt;&quot;, c.to_s, &quot;XML#dup{} should work&quot;)
</span><span class="marked0"><a name="line145" />145         assert_equal(&quot;&lt;foo a='1'&gt;Hello, world!&lt;/foo&gt;&quot;, d.to_s, &quot;XML#dup{} should work&quot;)
</span><span class="inferred1"><a name="line146" />146        
</span><span class="inferred0"><a name="line147" />147         # Deep copy test
</span><span class="marked1"><a name="line148" />148         a = XML.new(:h3, &quot;Hello&quot;)
</span><span class="marked0"><a name="line149" />149         b = XML.new(:foo, XML.new(:bar, a))
</span><span class="marked1"><a name="line150" />150         c = b.dup
</span><span class="marked0"><a name="line151" />151         a &lt;&lt; &quot;, world!&quot;
</span><span class="inferred1"><a name="line152" />152        
</span><span class="marked0"><a name="line153" />153         assert_equal(&quot;&lt;foo&gt;&lt;bar&gt;&lt;h3&gt;Hello, world!&lt;/h3&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;, b.to_s, &quot;XML#dup should make a deep copy&quot;)
</span><span class="marked1"><a name="line154" />154         assert_equal(&quot;&lt;foo&gt;&lt;bar&gt;&lt;h3&gt;Hello&lt;/h3&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;, c.to_s, &quot;XML#dup should make a deep copy&quot;)
</span><span class="inferred0"><a name="line155" />155     end
</span><span class="inferred1"><a name="line156" />156    
</span><span class="inferred0"><a name="line157" />157     # Test XML#normalize! method
</span><span class="marked1"><a name="line158" />158     def test_normalize
</span><span class="marked0"><a name="line159" />159         a = XML.new(:foo, &quot;He&quot;, &quot;&quot;, &quot;llo&quot;)
</span><span class="marked1"><a name="line160" />160         b = XML.new(:foo, &quot;&quot;)
</span><span class="marked0"><a name="line161" />161         c = XML.new(:foo, &quot;&quot;, XML.new(:bar, &quot;1&quot;), &quot;&quot;, XML.new(:bar, &quot;2&quot;, &quot;&quot;), &quot;X&quot;, XML.new(:bar, &quot;&quot;, &quot;3&quot;), &quot;&quot;)
</span><span class="inferred1"><a name="line162" />162 
</span><span class="marked0"><a name="line163" />163         a.normalize!
</span><span class="marked1"><a name="line164" />164         b.normalize!
</span><span class="marked0"><a name="line165" />165         c.normalize!
</span><span class="inferred1"><a name="line166" />166 
</span><span class="marked0"><a name="line167" />167         assert_equal([&quot;Hello&quot;], a.contents, &quot;XML#normalize! should work&quot;)
</span><span class="marked1"><a name="line168" />168         assert_equal([], b.contents, &quot;XML#normalize! should work&quot;)
</span><span class="marked0"><a name="line169" />169         assert_equal([XML.new(:bar, &quot;1&quot;), XML.new(:bar, &quot;2&quot;), &quot;X&quot;, XML.new(:bar, &quot;3&quot;)], c.contents, &quot;XML#normalize! should work&quot;)
</span><span class="inferred1"><a name="line170" />170     end
</span><span class="inferred0"><a name="line171" />171 
</span><span class="inferred1"><a name="line172" />172     # Test the &quot;monadic&quot; interface, that is constructors
</span><span class="inferred0"><a name="line173" />173     # with instance_eval'd blocks passed to them:
</span><span class="inferred1"><a name="line174" />174     # XML.new(:foo) { bar! } # -&gt; &lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;
</span><span class="marked0"><a name="line175" />175     def test_monadic
</span><span class="marked1"><a name="line176" />176         a = XML.new(:foo) { bar!; xml!(:xxx) }
</span><span class="marked0"><a name="line177" />177         b = xml(:div) {
</span><span class="marked1"><a name="line178" />178             ul! {
</span><span class="marked0"><a name="line179" />179                 li!(XML.a(&quot;Hello&quot;))
</span><span class="inferred1"><a name="line180" />180             }
</span><span class="inferred0"><a name="line181" />181         }
</span><span class="marked1"><a name="line182" />182         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;xxx/&gt;&lt;/foo&gt;&quot;, a.to_s, &quot;Monadic interface should work&quot;)
</span><span class="marked0"><a name="line183" />183         assert_equal(&quot;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;a&gt;Hello&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&quot;, b.to_s, &quot;Monadic interface should work&quot;)
</span><span class="inferred1"><a name="line184" />184     end
</span><span class="inferred0"><a name="line185" />185     
</span><span class="inferred1"><a name="line186" />186     # Test if parsing and printing gives the right results
</span><span class="inferred0"><a name="line187" />187     # We test mostly round-trip
</span><span class="marked1"><a name="line188" />188     def test_parse
</span><span class="marked0"><a name="line189" />189         a = &quot;&lt;foo/&gt;&quot;
</span><span class="marked1"><a name="line190" />190         b = &quot;&lt;foo a='1'/&gt;&quot;
</span><span class="marked0"><a name="line191" />191         c = &quot;&lt;foo&gt;Hello&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line192" />192         d = &quot;&lt;foo a='1'&gt;&lt;bar b='2'&gt;Hello&lt;/bar&gt;&lt;bar b='3'&gt;world&lt;/bar&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line193" />193         e = &quot;&lt;foo&gt;&amp;gt; &amp;lt; &amp;amp;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line194" />194         f = &quot;&lt;foo a='b&amp;amp;c'/&gt;&quot;
</span><span class="inferred0"><a name="line195" />195         
</span><span class="marked1"><a name="line196" />196         assert_equal(a, XML.parse(a).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="marked0"><a name="line197" />197         assert_equal(b, XML.parse(b).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="marked1"><a name="line198" />198         assert_equal(c, XML.parse(c).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="marked0"><a name="line199" />199         assert_equal(d, XML.parse(d).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="marked1"><a name="line200" />200         assert_equal(e, XML.parse(e).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="marked0"><a name="line201" />201         assert_equal(f, XML.parse(f).to_s, &quot;XML.parse(x).to_s should equal x for normalized x&quot;)
</span><span class="inferred1"><a name="line202" />202     end
</span><span class="inferred0"><a name="line203" />203 
</span><span class="inferred1"><a name="line204" />204     # Test parsing &amp;-entities
</span><span class="marked0"><a name="line205" />205     def test_parse_extra_escapes
</span><span class="marked1"><a name="line206" />206         a     = &quot;&lt;foo&gt;&amp;quot; &amp;apos;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line207" />207         a_out = &quot;&lt;foo&gt;\&quot; '&lt;/foo&gt;&quot;
</span><span class="inferred1"><a name="line208" />208 
</span><span class="marked0"><a name="line209" />209         assert_equal(a_out, XML.parse(a).to_s, &quot;XML.parse(x).to_s should normalize entities in x&quot;)
</span><span class="inferred1"><a name="line210" />210     end
</span><span class="inferred0"><a name="line211" />211 
</span><span class="inferred1"><a name="line212" />212     # Test handling extra cruft
</span><span class="inferred0"><a name="line213" />213     # Some things are best ignored or normalized
</span><span class="marked1"><a name="line214" />214     def test_parse_extra_cdata
</span><span class="marked0"><a name="line215" />215         a     = &quot;&lt;foo&gt;&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line216" />216         a_out = &quot;&lt;foo&gt;&amp;lt;greeting&amp;gt;Hello, world!&amp;lt;/greeting&amp;gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line217" />217         assert_equal(a_out, XML.parse(a).to_s, &quot;XML.parse(x).to_s should equal normalized x&quot;)
</span><span class="inferred1"><a name="line218" />218     end
</span><span class="inferred0"><a name="line219" />219 
</span><span class="inferred1"><a name="line220" />220     # Test handling (=ignoring) XML declarations
</span><span class="marked0"><a name="line221" />221     def test_parse_extra_qxml
</span><span class="marked1"><a name="line222" />222         b     = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</span><span class="marked0"><a name="line223" />223         b_out = &quot;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</span><span class="marked1"><a name="line224" />224         assert_equal(b_out, XML.parse(b).to_s, &quot;XML.parse(x).to_s should equal normalized x&quot;)
</span><span class="inferred0"><a name="line225" />225     end
</span><span class="inferred1"><a name="line226" />226 
</span><span class="inferred0"><a name="line227" />227     # Test handling (=ignoring) DTDs
</span><span class="marked1"><a name="line228" />228     def test_parse_extra_dtd
</span><span class="marked0"><a name="line229" />229         c     = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;&lt;!DOCTYPE greeting [&lt;!ELEMENT greeting (#PCDATA)&gt;]&gt;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</span><span class="marked1"><a name="line230" />230         c_out = &quot;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</span><span class="marked0"><a name="line231" />231         assert_equal(c_out, XML.parse(c).to_s, &quot;XML.parse(x).to_s should equal normalized x&quot;)
</span><span class="inferred1"><a name="line232" />232     end
</span><span class="inferred0"><a name="line233" />233 
</span><span class="inferred1"><a name="line234" />234     # Test handling (=ignoring) DTDs
</span><span class="marked0"><a name="line235" />235     def test_parse_extra_comment
</span><span class="marked1"><a name="line236" />236         c     = &quot;&lt;!-- this is a comment --&gt;&lt;greeting&gt;Hello,&lt;!-- another comment --&gt; world!&lt;/greeting&gt;&quot;
</span><span class="marked0"><a name="line237" />237         c_out = &quot;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</span><span class="marked1"><a name="line238" />238         assert_equal(c_out, XML.parse(c).to_s, &quot;XML.parse(x).to_s should equal normalized x&quot;)
</span><span class="inferred0"><a name="line239" />239     end
</span><span class="inferred1"><a name="line240" />240 
</span><span class="inferred0"><a name="line241" />241     # Test reading from a file
</span><span class="marked1"><a name="line242" />242     def test_parse_file
</span><span class="marked0"><a name="line243" />243         a = File.open(&quot;test.xml&quot;).xml_parse
</span><span class="marked1"><a name="line244" />244         b = XML.from_file(&quot;test.xml&quot;)
</span><span class="marked0"><a name="line245" />245         c = XML.from_url(&quot;file:test.xml&quot;)
</span><span class="marked1"><a name="line246" />246         d = XML.from_url(&quot;string:&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line247" />247         e = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line248" />248         f = &quot;&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;.xml_parse
</span><span class="marked0"><a name="line249" />249         g = XML.foo { bar! }
</span><span class="inferred1"><a name="line250" />250         
</span><span class="marked0"><a name="line251" />251         assert_equal(g.to_s, a.to_s, &quot;File#xml_parse should work&quot;)
</span><span class="marked1"><a name="line252" />252         assert_equal(g.to_s, b.to_s, &quot;XML.from_file should work&quot;)
</span><span class="marked0"><a name="line253" />253         assert_equal(g.to_s, c.to_s, &quot;XML.from_url(\&quot;file:...\&quot;) should work&quot;)
</span><span class="marked1"><a name="line254" />254         assert_equal(g.to_s, d.to_s, &quot;XML.from_url(\&quot;string:...\&quot;) should work&quot;)
</span><span class="marked0"><a name="line255" />255         assert_equal(g.to_s, e.to_s, &quot;XML.parse should work&quot;)
</span><span class="marked1"><a name="line256" />256         assert_equal(g.to_s, f.to_s, &quot;String#xml_parse should work&quot;)
</span><span class="inferred0"><a name="line257" />257     end
</span><span class="inferred1"><a name="line258" />258 
</span><span class="inferred0"><a name="line259" />259     # Test XML#children and Array#children
</span><span class="marked1"><a name="line260" />260     def test_chilrden
</span><span class="marked0"><a name="line261" />261         a = XML.bar({:x=&gt;&quot;1&quot;})
</span><span class="marked1"><a name="line262" />262         b = XML.bar({:x=&gt;&quot;3&quot;})
</span><span class="marked0"><a name="line263" />263         c = XML.bar({:x=&gt;&quot;2&quot;}, b)
</span><span class="marked1"><a name="line264" />264         d = XML.foo(a,c)
</span><span class="marked0"><a name="line265" />265         e = d.children(:bar)
</span><span class="marked1"><a name="line266" />266         f = e.children(:bar)
</span><span class="marked0"><a name="line267" />267         assert_equal([a,c], e, &quot;XML#children(tag) should return tag-tagged children&quot;)
</span><span class="marked1"><a name="line268" />268         assert_equal([b], f, &quot;Array#children(tag) should return tag-tagged children of its elements&quot;)
</span><span class="inferred0"><a name="line269" />269     end
</span><span class="inferred1"><a name="line270" />270     
</span><span class="inferred0"><a name="line271" />271     # Test XML#descendants and Array#descendants
</span><span class="marked1"><a name="line272" />272     def test_descendants
</span><span class="marked0"><a name="line273" />273         a = XML.bar({:x=&gt;&quot;1&quot;})
</span><span class="marked1"><a name="line274" />274         b = XML.bar({:x=&gt;&quot;3&quot;})
</span><span class="marked0"><a name="line275" />275         c = XML.bar({:x=&gt;&quot;2&quot;}, b)
</span><span class="marked1"><a name="line276" />276         d = XML.foo(a,c)
</span><span class="marked0"><a name="line277" />277         e = d.descendants(:bar)
</span><span class="marked1"><a name="line278" />278         f = e.descendants(:bar)
</span><span class="marked0"><a name="line279" />279         assert_equal([a,c,b], e, &quot;XML#descendants(tag) should return tag-tagged descendants&quot;)
</span><span class="marked1"><a name="line280" />280         assert_equal([b], f, &quot;Array#descendants(tag) should return tag-tagged descendants of its elements&quot;)
</span><span class="inferred0"><a name="line281" />281     end
</span><span class="inferred1"><a name="line282" />282 
</span><span class="inferred0"><a name="line283" />283     # Test XML#exec! monadic interface
</span><span class="marked1"><a name="line284" />284     def test_exec
</span><span class="marked0"><a name="line285" />285         a = XML.foo
</span><span class="marked1"><a name="line286" />286         a.exec! {
</span><span class="marked0"><a name="line287" />287             bar! { text! &quot;Hello&quot; }
</span><span class="marked1"><a name="line288" />288             text! &quot;world&quot;
</span><span class="inferred0"><a name="line289" />289         }
</span><span class="marked1"><a name="line290" />290         assert_equal(&quot;&lt;foo&gt;&lt;bar&gt;Hello&lt;/bar&gt;world&lt;/foo&gt;&quot;, a.to_s, &quot;XML#exec! should work&quot;)
</span><span class="inferred0"><a name="line291" />291     end
</span><span class="inferred1"><a name="line292" />292 
</span><span class="inferred0"><a name="line293" />293     # Test XML#child
</span><span class="marked1"><a name="line294" />294     def test_child
</span><span class="marked0"><a name="line295" />295         a = XML.parse(&quot;&lt;foo&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line296" />296         b = XML.parse(&quot;&lt;foo&gt;&lt;bar a='1'/&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line297" />297         c = XML.parse(&quot;&lt;foo&gt;&lt;bar a='1'/&gt;&lt;bar a='2'/&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred1"><a name="line298" />298 
</span><span class="marked0"><a name="line299" />299         assert_equal(nil, a.child(:bar), &quot;XML#child should return nil if there are no matching children&quot;)
</span><span class="marked1"><a name="line300" />300         assert_equal(&quot;&lt;bar a='1'/&gt;&quot;, b.child(:bar).to_s, &quot;XML#child should work&quot;)
</span><span class="marked0"><a name="line301" />301         assert_equal(&quot;&lt;bar a='1'/&gt;&quot;, c.child(:bar).to_s, &quot;XML#child should return first child if there are many&quot;)
</span><span class="marked1"><a name="line302" />302         assert_equal(&quot;&lt;bar a='2'/&gt;&quot;, c.child({:a =&gt; '2'}).to_s, &quot;XML#child should support patterns&quot;)
</span><span class="inferred0"><a name="line303" />303     end
</span><span class="inferred1"><a name="line304" />304 
</span><span class="inferred0"><a name="line305" />305     # Test XML#descendant
</span><span class="marked1"><a name="line306" />306     def test_descendant
</span><span class="marked0"><a name="line307" />307         a = XML.parse(&quot;&lt;foo&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line308" />308         b = XML.parse(&quot;&lt;foo&gt;&lt;bar a='1'/&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line309" />309         c = XML.parse(&quot;&lt;foo&gt;&lt;bar a='1'/&gt;&lt;bar a='2'/&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line310" />310         d = XML.parse(&quot;&lt;foo&gt;&lt;bar a='1'&gt;&lt;bar a='2'/&gt;&lt;/bar&gt;&lt;bar a='3'/&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line311" />311         e = XML.parse(&quot;&lt;foo&gt;&lt;foo&gt;&lt;bar a='1'/&gt;&lt;/foo&gt;&lt;bar a='2'/&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred1"><a name="line312" />312         
</span><span class="marked0"><a name="line313" />313         assert_equal(nil, a.descendant(:bar), &quot;XML#descendant should return nil if there are no matching descendants&quot;)
</span><span class="marked1"><a name="line314" />314         assert_equal(&quot;&lt;bar a='1'/&gt;&quot;, b.descendant(:bar).to_s, &quot;XML#descendant should work&quot;)
</span><span class="marked0"><a name="line315" />315         assert_equal(&quot;&lt;bar a='1'/&gt;&quot;, c.descendant(:bar).to_s, &quot;XML#descendant should return first descendant if there are many&quot;)
</span><span class="marked1"><a name="line316" />316         assert_equal(&quot;&lt;bar a='1'&gt;&lt;bar a='2'/&gt;&lt;/bar&gt;&quot;, d.descendant(:bar).to_s, &quot;XML#descendant should return first descendant if there are many&quot;)
</span><span class="marked0"><a name="line317" />317         assert_equal(&quot;&lt;bar a='1'/&gt;&quot;, e.descendant(:bar).to_s, &quot;XML#descendant should return first descendant if there are many&quot;)
</span><span class="marked1"><a name="line318" />318         assert_equal(&quot;&lt;bar a='2'/&gt;&quot;, c.descendant({:a =&gt; '2'}).to_s, &quot;XML#descendant should support patterns&quot;)
</span><span class="marked0"><a name="line319" />319         assert_equal(&quot;&lt;bar a='2'/&gt;&quot;, d.descendant({:a =&gt; '2'}).to_s, &quot;XML#descendant should support patterns&quot;)
</span><span class="marked1"><a name="line320" />320         assert_equal(&quot;&lt;bar a='2'/&gt;&quot;, e.descendant({:a =&gt; '2'}).to_s, &quot;XML#descendant should support patterns&quot;)
</span><span class="inferred0"><a name="line321" />321     end
</span><span class="inferred1"><a name="line322" />322     
</span><span class="inferred0"><a name="line323" />323     # Test XML#text
</span><span class="marked1"><a name="line324" />324     def test_text
</span><span class="marked0"><a name="line325" />325         a = XML.parse(&quot;&lt;foo&gt;Hello&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line326" />326         b = XML.parse(&quot;&lt;foo&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line327" />327         c = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;Hello&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line328" />328         d = XML.parse(&quot;&lt;foo&gt;He&lt;bar&gt;llo&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred0"><a name="line329" />329 
</span><span class="marked1"><a name="line330" />330         assert_equal(&quot;Hello&quot;, a.text, &quot;XML#text should work&quot;)
</span><span class="marked0"><a name="line331" />331         assert_equal(&quot;&quot;, b.text, &quot;XML#text should work&quot;)
</span><span class="marked1"><a name="line332" />332         assert_equal(&quot;Hello&quot;, c.text, &quot;XML#text should work&quot;)
</span><span class="marked0"><a name="line333" />333         assert_equal(&quot;Hello&quot;, d.text, &quot;XML#text should work&quot;)
</span><span class="inferred1"><a name="line334" />334     end
</span><span class="inferred0"><a name="line335" />335     
</span><span class="inferred1"><a name="line336" />336     # Test XML#renormalize and XML#renormalize_sequence
</span><span class="marked0"><a name="line337" />337     def test_renormalize
</span><span class="marked1"><a name="line338" />338         a = &quot;&lt;foo&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line339" />339         b = &quot;&lt;foo&gt;&lt;/foo&gt;&lt;bar&gt;&lt;/bar&gt;&quot;
</span><span class="inferred1"><a name="line340" />340         
</span><span class="marked0"><a name="line341" />341         assert_equal(&quot;&lt;foo/&gt;&quot;, XML.renormalize(a), &quot;XML#renormalize should work&quot;)
</span><span class="marked1"><a name="line342" />342         assert_equal(&quot;&lt;foo/&gt;&quot;, XML.renormalize_sequence(a), &quot;XML#renormalize_sequence should work&quot;)
</span><span class="marked0"><a name="line343" />343         assert_equal(&quot;&lt;foo/&gt;&lt;bar/&gt;&quot;, XML.renormalize_sequence(b), &quot;XML#renormalize_sequence should work&quot;)
</span><span class="inferred1"><a name="line344" />344     end
</span><span class="inferred0"><a name="line345" />345     
</span><span class="inferred1"><a name="line346" />346     # Test XML#range
</span><span class="marked0"><a name="line347" />347     def test_range
</span><span class="marked1"><a name="line348" />348         a = XML.parse &quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line349" />349         b = a.children(:bar)
</span><span class="inferred1"><a name="line350" />350         
</span><span class="inferred0"><a name="line351" />351         # Non-recursive case
</span><span class="marked1"><a name="line352" />352         ar_n_n = a.range(nil, nil)
</span><span class="marked0"><a name="line353" />353         ar_0_n = a.range(b[0], nil)
</span><span class="marked1"><a name="line354" />354         ar_1_n = a.range(b[1], nil)
</span><span class="marked0"><a name="line355" />355         ar_4_n = a.range(b[4], nil)
</span><span class="marked1"><a name="line356" />356         ar_n_4 = a.range(nil, b[4])
</span><span class="marked0"><a name="line357" />357         ar_n_3 = a.range(nil, b[3])
</span><span class="marked1"><a name="line358" />358         ar_n_0 = a.range(nil, b[0])
</span><span class="inferred0"><a name="line359" />359         
</span><span class="marked1"><a name="line360" />360         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;, ar_n_n.to_s, &quot;XML#range should work&quot;)
</span><span class="marked0"><a name="line361" />361         assert_equal(&quot;&lt;foo&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;, ar_0_n.to_s, &quot;XML#range should work&quot;)
</span><span class="marked1"><a name="line362" />362         assert_equal(&quot;&lt;foo&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;, ar_1_n.to_s, &quot;XML#range should work&quot;)
</span><span class="marked0"><a name="line363" />363         assert_equal(&quot;&lt;foo/&gt;&quot;, ar_4_n.to_s, &quot;XML#range should work&quot;)
</span><span class="marked1"><a name="line364" />364         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;/foo&gt;&quot;, ar_n_4.to_s, &quot;XML#range should work&quot;)
</span><span class="marked0"><a name="line365" />365         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;/foo&gt;&quot;, ar_n_3.to_s, &quot;XML#range should work&quot;)
</span><span class="marked1"><a name="line366" />366         assert_equal(&quot;&lt;foo/&gt;&quot;, ar_n_0.to_s, &quot;XML#range should work&quot;)
</span><span class="inferred0"><a name="line367" />367         
</span><span class="marked1"><a name="line368" />368         a = XML.parse &quot;&lt;a&gt;
</span><span class="inferred0"><a name="line369" />369                        &lt;b i='0'&gt;&lt;c i='0'/&gt;&lt;c i='1'/&gt;&lt;c i='2'/&gt;&lt;/b&gt;
</span><span class="inferred1"><a name="line370" />370                        &lt;b i='1'&gt;&lt;c i='3'/&gt;&lt;c i='4'/&gt;&lt;c i='5'/&gt;&lt;/b&gt;
</span><span class="inferred0"><a name="line371" />371                        &lt;b i='2'&gt;&lt;c i='6'/&gt;&lt;c i='7'/&gt;&lt;c i='8'/&gt;&lt;/b&gt;
</span><span class="inferred1"><a name="line372" />372                        &lt;/a&gt;&quot;
</span><span class="marked0"><a name="line373" />373         c = a.descendants(:c)
</span><span class="inferred1"><a name="line374" />374        
</span><span class="marked0"><a name="line375" />375         c.each_with_index{|ci,i|
</span><span class="marked1"><a name="line376" />376             c.each_with_index{|cj,j|
</span><span class="marked0"><a name="line377" />377                 next unless i &lt; j
</span><span class="marked1"><a name="line378" />378                 ar = a.range(ci,cj)
</span><span class="marked0"><a name="line379" />379                 cs_present = ar.descendants(:c).map{|n|n[:i].to_i}
</span><span class="marked1"><a name="line380" />380                 assert_equal(((i+1)...j).to_a, cs_present, &quot;XML#range(c#{i}, c#{j}) should contain cs between #{i} and #{j}, exclusive, instead got: #{ar}&quot;)
</span><span class="inferred0"><a name="line381" />381             }
</span><span class="marked1"><a name="line382" />382             ar = a.range(ci,nil)
</span><span class="marked0"><a name="line383" />383             cs_present = ar.descendants(:c).map{|n|n[:i].to_i}
</span><span class="marked1"><a name="line384" />384             assert_equal(((i+1)..8).to_a, cs_present, &quot;XML#range(c#{i}, nil) should contain cs from #{i+1} to 8, instead got: #{ar}&quot;)
</span><span class="inferred0"><a name="line385" />385             
</span><span class="marked1"><a name="line386" />386             ar = a.range(nil,ci)
</span><span class="marked0"><a name="line387" />387             cs_present = ar.descendants(:c).map{|n|n[:i].to_i}
</span><span class="marked1"><a name="line388" />388             assert_equal((0...i).to_a, cs_present, &quot;XML#range(nil, c#{i}) should contain cs from 0 to #{i-1}, instead got: #{ar}&quot;)
</span><span class="inferred0"><a name="line389" />389         }
</span><span class="inferred1"><a name="line390" />390     end
</span><span class="inferred0"><a name="line391" />391 
</span><span class="inferred1"><a name="line392" />392     # Test XML#subsequence
</span><span class="marked0"><a name="line393" />393     def test_subsequence
</span><span class="marked1"><a name="line394" />394         a = XML.parse &quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line395" />395         b = a.children(:bar)
</span><span class="inferred1"><a name="line396" />396         
</span><span class="inferred0"><a name="line397" />397         # Non-recursive case
</span><span class="marked1"><a name="line398" />398         ar_n_n = a.subsequence(nil, nil)
</span><span class="marked0"><a name="line399" />399         ar_0_n = a.subsequence(b[0], nil)
</span><span class="marked1"><a name="line400" />400         ar_1_n = a.subsequence(b[1], nil)
</span><span class="marked0"><a name="line401" />401         ar_4_n = a.subsequence(b[4], nil)
</span><span class="marked1"><a name="line402" />402         ar_n_4 = a.subsequence(nil, b[4])
</span><span class="marked0"><a name="line403" />403         ar_n_3 = a.subsequence(nil, b[3])
</span><span class="marked1"><a name="line404" />404         ar_n_0 = a.subsequence(nil, b[0])
</span><span class="inferred0"><a name="line405" />405         
</span><span class="marked1"><a name="line406" />406         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&lt;/foo&gt;&quot;, ar_n_n.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked0"><a name="line407" />407         assert_equal(&quot;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&quot;, ar_0_n.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked1"><a name="line408" />408         assert_equal(&quot;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;bar i='4'/&gt;&quot;, ar_1_n.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked0"><a name="line409" />409         assert_equal(&quot;&quot;, ar_4_n.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked1"><a name="line410" />410         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;bar i='3'/&gt;&lt;/foo&gt;&quot;, ar_n_4.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked0"><a name="line411" />411         assert_equal(&quot;&lt;foo&gt;&lt;bar i='0'/&gt;&lt;bar i='1'/&gt;&lt;bar i='2'/&gt;&lt;/foo&gt;&quot;, ar_n_3.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="marked1"><a name="line412" />412         assert_equal(&quot;&lt;foo/&gt;&quot;, ar_n_0.to_s, &quot;XML#subsequence should work&quot;)
</span><span class="inferred0"><a name="line413" />413         
</span><span class="marked1"><a name="line414" />414         a = XML.parse &quot;&lt;a&gt;
</span><span class="inferred0"><a name="line415" />415                        &lt;b j='0'&gt;&lt;c i='0'/&gt;&lt;c i='1'/&gt;&lt;c i='2'/&gt;&lt;/b&gt;
</span><span class="inferred1"><a name="line416" />416                        &lt;b j='1'&gt;&lt;c i='3'/&gt;&lt;c i='4'/&gt;&lt;c i='5'/&gt;&lt;/b&gt;
</span><span class="inferred0"><a name="line417" />417                        &lt;b j='2'&gt;&lt;c i='6'/&gt;&lt;c i='7'/&gt;&lt;c i='8'/&gt;&lt;/b&gt;
</span><span class="inferred1"><a name="line418" />418                        &lt;/a&gt;&quot;
</span><span class="marked0"><a name="line419" />419         c = a.descendants(:c)
</span><span class="inferred1"><a name="line420" />420        
</span><span class="inferred0"><a name="line421" />421         # (ar + ar.descendants).find_all{|x| x.is_a? XML and x.name == :c}
</span><span class="inferred1"><a name="line422" />422         # instead of ar.descendants(:c) because 
</span><span class="inferred0"><a name="line423" />423         # we might have returned [&lt;c i='?'/&gt;] as a result,
</span><span class="inferred1"><a name="line424" />424         # and then it's not a descendant of the result then.
</span><span class="inferred0"><a name="line425" />425         # This is ugly, and it should be fixed somewhere in magic/xml
</span><span class="marked1"><a name="line426" />426         c.each_with_index{|ci,i|
</span><span class="marked0"><a name="line427" />427             c.each_with_index{|cj,j|
</span><span class="marked1"><a name="line428" />428                 next unless i &lt; j
</span><span class="marked0"><a name="line429" />429                 ar = a.subsequence(ci,cj)
</span><span class="marked1"><a name="line430" />430                 cs_present = (ar + ar.descendants).find_all{|x| x.is_a? XML and x.name == :c}.map{|n| n[:i].to_i}
</span><span class="marked0"><a name="line431" />431                 assert_equal(((i+1)...j).to_a, cs_present, &quot;XML#subsequence(c#{i}, c#{j}) should contain cs between #{i} and #{j}, exclusive, instead got: #{ar}&quot;)
</span><span class="inferred1"><a name="line432" />432             }
</span><span class="marked0"><a name="line433" />433             ar = a.subsequence(ci,nil)
</span><span class="marked1"><a name="line434" />434             cs_present = (ar + ar.descendants).find_all{|x| x.is_a? XML and x.name == :c}.map{|n| n[:i].to_i}
</span><span class="marked0"><a name="line435" />435             assert_equal(((i+1)..8).to_a, cs_present, &quot;XML#subsequence(c#{i}, nil) should contain cs from #{i+1} to 8, instead got: #{ar}&quot;)
</span><span class="inferred1"><a name="line436" />436             
</span><span class="marked0"><a name="line437" />437             ar = a.subsequence(nil,ci)
</span><span class="marked1"><a name="line438" />438             cs_present = (ar + ar.descendants).find_all{|x| x.is_a? XML and x.name == :c}.map{|n| n[:i].to_i}
</span><span class="marked0"><a name="line439" />439             assert_equal((0...i).to_a, cs_present, &quot;XML#subsequence(nil, c#{i}) should contain cs from 0 to #{i-1}, instead got: #{ar}&quot;)
</span><span class="inferred1"><a name="line440" />440         }
</span><span class="inferred0"><a name="line441" />441     end
</span><span class="inferred1"><a name="line442" />442     
</span><span class="inferred0"><a name="line443" />443     # Test xml! at top level
</span><span class="marked1"><a name="line444" />444     def test_xml_bang
</span><span class="marked0"><a name="line445" />445         real_stdout = $stdout
</span><span class="marked1"><a name="line446" />446         $stdout = StringIO.new
</span><span class="marked0"><a name="line447" />447         xml!(:foo)
</span><span class="marked1"><a name="line448" />448         assert_equal(&quot;&lt;foo/&gt;&quot;, $stdout.string, &quot;xml! should work&quot;)
</span><span class="inferred0"><a name="line449" />449         
</span><span class="marked1"><a name="line450" />450         $stdout = StringIO.new
</span><span class="marked0"><a name="line451" />451         XML.bar!
</span><span class="marked1"><a name="line452" />452         assert_equal(&quot;&lt;bar/&gt;&quot;, $stdout.string, &quot;XML#foo! should work&quot;)
</span><span class="marked0"><a name="line453" />453         $stdout = real_stdout
</span><span class="inferred1"><a name="line454" />454     end
</span><span class="inferred0"><a name="line455" />455     
</span><span class="inferred1"><a name="line456" />456     # Methods XML#foo! are all catched,
</span><span class="inferred0"><a name="line457" />457     # but how about other methods ?
</span><span class="marked1"><a name="line458" />458     def test_real_method_missing
</span><span class="marked0"><a name="line459" />459         foo = XML.new(:foo)
</span><span class="marked1"><a name="line460" />460         exception_raised = false
</span><span class="marked0"><a name="line461" />461         begin 
</span><span class="marked1"><a name="line462" />462             foo.bar()
</span><span class="inferred0"><a name="line463" />463         rescue NoMethodError
</span><span class="marked1"><a name="line464" />464             exception_raised = true
</span><span class="inferred0"><a name="line465" />465         end
</span><span class="inferred1"><a name="line466" />466         # FIXME: There are other assertions than assert_equal ;-)
</span><span class="marked0"><a name="line467" />467         assert_equal(true, exception_raised, &quot;XML#bar should raise NoMethodError&quot;)
</span><span class="inferred1"><a name="line468" />468     end
</span><span class="inferred0"><a name="line469" />469     
</span><span class="inferred1"><a name="line470" />470     # Test XML#parse_as_twigs interface
</span><span class="marked0"><a name="line471" />471     def test_parse_as_twigs
</span><span class="marked1"><a name="line472" />472         stream = &quot;&lt;foo&gt;&lt;p&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p/&gt;&lt;p&gt;&lt;bar/&gt;&lt;/p&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line473" />473         i = 0
</span><span class="marked1"><a name="line474" />474         results = []
</span><span class="marked0"><a name="line475" />475         XML.parse_as_twigs(stream) {|n|
</span><span class="marked1"><a name="line476" />476             n.complete! if i == 1 or i == 3
</span><span class="marked0"><a name="line477" />477             results &lt;&lt; n
</span><span class="marked1"><a name="line478" />478             i += 1
</span><span class="inferred0"><a name="line479" />479         }
</span><span class="marked1"><a name="line480" />480         assert_equal(&quot;&lt;foo/&gt;&quot;, results[0].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked0"><a name="line481" />481         assert_equal(&quot;&lt;p&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&quot;, results[1].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked1"><a name="line482" />482         assert_equal(&quot;&lt;p/&gt;&quot;, results[2].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked0"><a name="line483" />483         assert_equal(&quot;&lt;br/&gt;&quot;, results[3].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked1"><a name="line484" />484         assert_equal(&quot;&lt;p/&gt;&quot;, results[4].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked0"><a name="line485" />485         assert_equal(&quot;&lt;p/&gt;&quot;, results[5].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked1"><a name="line486" />486         assert_equal(&quot;&lt;bar/&gt;&quot;, results[6].to_s, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="marked0"><a name="line487" />487         assert_equal(7, results.size, &quot;XML.parse_as_twigs should work&quot;)
</span><span class="inferred1"><a name="line488" />488     end
</span><span class="inferred0"><a name="line489" />489 
</span><span class="inferred1"><a name="line490" />490     # Test XML#inspect
</span><span class="marked0"><a name="line491" />491     def test_inpsect
</span><span class="marked1"><a name="line492" />492         a = xml(:a, xml(:b, xml(:c)))
</span><span class="marked0"><a name="line493" />493         d = xml(:d)
</span><span class="inferred1"><a name="line494" />494         
</span><span class="marked0"><a name="line495" />495         assert_equal(&quot;&lt;a&gt;...&lt;/a&gt;&quot;, a.inspect, &quot;XML#inspect should work&quot;)
</span><span class="marked1"><a name="line496" />496         assert_equal(&quot;&lt;a&gt;...&lt;/a&gt;&quot;, a.inspect(0), &quot;XML#inspect(levels) should work&quot;)
</span><span class="marked0"><a name="line497" />497         assert_equal(&quot;&lt;a&gt;&lt;b&gt;...&lt;/b&gt;&lt;/a&gt;&quot;, a.inspect(1), &quot;XML#inspect(levels) should work&quot;)
</span><span class="marked1"><a name="line498" />498         assert_equal(&quot;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&quot;, a.inspect(2), &quot;XML#inspect(levels) should work&quot;)
</span><span class="marked0"><a name="line499" />499         assert_equal(&quot;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&quot;, a.inspect(3), &quot;XML#inspect(levels) should work&quot;)
</span><span class="marked1"><a name="line500" />500         assert_equal(&quot;&lt;d/&gt;&quot;, d.inspect, &quot;XML#inspect should work&quot;)
</span><span class="marked0"><a name="line501" />501         assert_equal(&quot;&lt;d/&gt;&quot;, d.inspect(0), &quot;XML#inspect should work&quot;)
</span><span class="marked1"><a name="line502" />502         assert_equal(&quot;&lt;d/&gt;&quot;, d.inspect(1), &quot;XML#inspect should work&quot;)
</span><span class="inferred0"><a name="line503" />503     end
</span><span class="inferred1"><a name="line504" />504     
</span><span class="inferred0"><a name="line505" />505     # Test XML#[:@foo] pseudoattributes
</span><span class="marked1"><a name="line506" />506     def test_pseudoattributes_read
</span><span class="inferred0"><a name="line507" />507         # Ignore the second &lt;x&gt;...&lt;/x&gt;
</span><span class="marked1"><a name="line508" />508         a = XML.parse(&quot;&lt;foo x='10'&gt;&lt;x&gt;20&lt;/x&gt;&lt;y&gt;30&lt;/y&gt;&lt;x&gt;40&lt;/x&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred0"><a name="line509" />509         
</span><span class="marked1"><a name="line510" />510         assert_equal(&quot;10&quot;, a[:x],  &quot;XML#[] real attributes should work&quot;)
</span><span class="marked0"><a name="line511" />511         assert_nil(a[:y],  &quot;XML#[] real attributes should work&quot;)
</span><span class="marked1"><a name="line512" />512         assert_nil(a[:z],  &quot;XML#[] real attributes should work&quot;)
</span><span class="marked0"><a name="line513" />513         assert_equal(&quot;20&quot;, a[:@x], &quot;XML#[] pseudoattributes should work&quot;)
</span><span class="marked1"><a name="line514" />514         assert_equal(&quot;30&quot;, a[:@y], &quot;XML#[] pseudoattributes should work&quot;)
</span><span class="marked0"><a name="line515" />515         assert_nil(a[:@z], &quot;XML#[] pseudoattributes should work&quot;)
</span><span class="inferred1"><a name="line516" />516     end
</span><span class="inferred0"><a name="line517" />517 
</span><span class="inferred1"><a name="line518" />518     # Test XML#[:@foo] pseudoattributes
</span><span class="marked0"><a name="line519" />519     def test_pseudoattributes_write
</span><span class="inferred1"><a name="line520" />520         # Ignore the second &lt;x&gt;...&lt;/x&gt;
</span><span class="marked0"><a name="line521" />521         a = XML.parse(&quot;&lt;foo x='10'&gt;&lt;x&gt;20&lt;/x&gt;&lt;y&gt;30&lt;/y&gt;&lt;x&gt;40&lt;/x&gt;&lt;/foo&gt;&quot;)
</span><span class="inferred1"><a name="line522" />522         
</span><span class="marked0"><a name="line523" />523         a[:x] = 100
</span><span class="marked1"><a name="line524" />524         a[:y] = 200
</span><span class="marked0"><a name="line525" />525         a[:z] = 300
</span><span class="marked1"><a name="line526" />526         a[:@x] = 1000
</span><span class="marked0"><a name="line527" />527         a[:@y] = 2000
</span><span class="marked1"><a name="line528" />528         a[:@z] = 3000
</span><span class="inferred0"><a name="line529" />529         
</span><span class="marked1"><a name="line530" />530         assert_equal(&quot;&lt;foo x='100' y='200' z='300'&gt;&lt;x&gt;1000&lt;/x&gt;&lt;y&gt;2000&lt;/y&gt;&lt;x&gt;40&lt;/x&gt;&lt;z&gt;3000&lt;/z&gt;&lt;/foo&gt;&quot;, a.to_s, &quot;XML#[]= pseudoattributes should work&quot;)
</span><span class="inferred0"><a name="line531" />531     end
</span><span class="inferred1"><a name="line532" />532     
</span><span class="inferred0"><a name="line533" />533     # Test entity unescaping
</span><span class="marked1"><a name="line534" />534     def test_entities
</span><span class="marked0"><a name="line535" />535         a = XML.parse(&quot;&lt;foo&gt;&amp;#xA5;&amp;#xFC;&amp;#x2020;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line536" />536         b = XML.parse(&quot;&lt;foo&gt;&amp;#165;&amp;#252;&amp;#8224;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line537" />537         c = XML.parse(&quot;&lt;foo&gt;&amp;yen;&amp;uuml;&amp;dagger;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line538" />538         d = &quot;&quot;
</span><span class="inferred0"><a name="line539" />539         
</span><span class="marked1"><a name="line540" />540         assert_equal(b.text, a.text, &quot;Entity unescaping on XML#Parse should work&quot;)
</span><span class="marked0"><a name="line541" />541         assert_equal(c.text, a.text, &quot;Entity unescaping on XML#Parse should work&quot;)
</span><span class="inferred1"><a name="line542" />542 
</span><span class="marked0"><a name="line543" />543         assert_equal(b.to_s, a.to_s, &quot;Entity escaping on XML#to_s should work&quot;)
</span><span class="marked1"><a name="line544" />544         assert_equal(c.to_s, a.to_s, &quot;Entity escaping on XML#to_s should work&quot;)
</span><span class="inferred0"><a name="line545" />545 
</span><span class="inferred1"><a name="line546" />546         # The escapes assume \XXX are byte escapes and the encoding is UTF-8
</span><span class="marked0"><a name="line547" />547         assert_equal(&quot;\302\245\303\274\342\200\240&quot;, a.text, &quot;Entity unescaping on XML#Parse should work&quot;)
</span><span class="marked1"><a name="line548" />548         assert_equal(&quot;&lt;foo&gt;\302\245\303\274\342\200\240&lt;/foo&gt;&quot;, a.to_s, &quot;Entity escaping on XML#to_s should work&quot;)
</span><span class="inferred0"><a name="line549" />549     end
</span><span class="inferred1"><a name="line550" />550 
</span><span class="inferred0"><a name="line551" />551     # Test patterns support
</span><span class="marked1"><a name="line552" />552     def test_patterns
</span><span class="marked0"><a name="line553" />553         a = XML.parse &quot;&lt;foo&gt;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;, &lt;bar color='red'&gt;world&lt;/bar&gt;&lt;excl&gt;!&lt;/excl&gt;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line554" />554         a.normalize!
</span><span class="inferred0"><a name="line555" />555         
</span><span class="marked1"><a name="line556" />556         blue    = []
</span><span class="marked0"><a name="line557" />557         nocolor = []
</span><span class="marked1"><a name="line558" />558         bar     = []
</span><span class="inferred0"><a name="line559" />559         #hello   = []
</span><span class="inferred1"><a name="line560" />560         
</span><span class="marked0"><a name="line561" />561         a.descendants {|d|
</span><span class="marked1"><a name="line562" />562             case d
</span><span class="marked0"><a name="line563" />563             when :bar
</span><span class="marked1"><a name="line564" />564                 bar &lt;&lt; d
</span><span class="inferred0"><a name="line565" />565             end
</span><span class="inferred1"><a name="line566" />566 
</span><span class="marked0"><a name="line567" />567             case d
</span><span class="marked1"><a name="line568" />568             when {:color =&gt; 'blue'}
</span><span class="marked0"><a name="line569" />569                 blue &lt;&lt; d
</span><span class="inferred1"><a name="line570" />570             end
</span><span class="inferred0"><a name="line571" />571         
</span><span class="marked1"><a name="line572" />572             case d
</span><span class="marked0"><a name="line573" />573             when {:color =&gt; nil}
</span><span class="marked1"><a name="line574" />574                 nocolor &lt;&lt; d
</span><span class="inferred0"><a name="line575" />575             end
</span><span class="inferred1"><a name="line576" />576         
</span><span class="inferred0"><a name="line577" />577             #case d
</span><span class="inferred1"><a name="line578" />578             #when /Hello/
</span><span class="inferred0"><a name="line579" />579             #    hello &lt;&lt; d
</span><span class="inferred1"><a name="line580" />580             #end
</span><span class="inferred0"><a name="line581" />581         }
</span><span class="inferred1"><a name="line582" />582         
</span><span class="marked0"><a name="line583" />583         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;bar color='red'&gt;world&lt;/bar&gt;&quot;)], bar, &quot;Pattern matching should work&quot;)
</span><span class="marked1"><a name="line584" />584         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;)], blue, &quot;Pattern matching should work&quot;)
</span><span class="marked0"><a name="line585" />585         assert_equal([XML.parse(&quot;&lt;excl&gt;!&lt;/excl&gt;&quot;)], nocolor, &quot;Pattern matching should work&quot;)
</span><span class="inferred1"><a name="line586" />586         # Commented out, as it requires overloading Regexp#=~ and therefore Binding.of_caller
</span><span class="inferred0"><a name="line587" />587         #assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), &quot;Hello&quot;], hello, &quot;Pattern matching should work&quot;)
</span><span class="inferred1"><a name="line588" />588     end
</span><span class="inferred0"><a name="line589" />589 
</span><span class="inferred1"><a name="line590" />590     # Test pattern support in #descendants (works the same way in #children)
</span><span class="marked0"><a name="line591" />591     def test_patterns_2
</span><span class="marked1"><a name="line592" />592         a = XML.parse &quot;&lt;foo&gt;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;, &lt;bar color='red'&gt;world&lt;/bar&gt;&lt;excl color='blue'&gt;!&lt;/excl&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line593" />593         a.normalize!
</span><span class="inferred1"><a name="line594" />594         
</span><span class="marked0"><a name="line595" />595         bar      = a.descendants(:bar)
</span><span class="marked1"><a name="line596" />596         blue     = a.descendants({:color=&gt;'blue'})
</span><span class="marked0"><a name="line597" />597         blue_bar = a.descendants(all(:bar, {:color=&gt;'blue'}))
</span><span class="inferred1"><a name="line598" />598         #hello    = a.descendants(/Hello/)
</span><span class="marked0"><a name="line599" />599         xml      = a.descendants(XML)
</span><span class="marked1"><a name="line600" />600         string   = a.descendants(String)
</span><span class="inferred0"><a name="line601" />601     
</span><span class="marked1"><a name="line602" />602         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;bar color='red'&gt;world&lt;/bar&gt;&quot;)], bar, &quot;Pattern matching should work&quot;)
</span><span class="marked0"><a name="line603" />603         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;excl color='blue'&gt;!&lt;/excl&gt;&quot;)], blue, &quot;Pattern matching should work&quot;)
</span><span class="marked1"><a name="line604" />604         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;)], blue_bar, &quot;Pattern matching should work&quot;)
</span><span class="inferred0"><a name="line605" />605         # Commented out, as it requires overloading Regexp#=~ and therefore Binding.of_caller
</span><span class="inferred1"><a name="line606" />606         #assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), &quot;Hello&quot;], hello, &quot;Pattern matching should work&quot;)
</span><span class="marked0"><a name="line607" />607         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;bar color='red'&gt;world&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;excl color='blue'&gt;!&lt;/excl&gt;&quot;)], xml, &quot;Pattern matching should work&quot;)
</span><span class="marked1"><a name="line608" />608         assert_equal(['Hello', ', ', 'world', '!'], string, &quot;Pattern matching should work&quot;)
</span><span class="inferred0"><a name="line609" />609     end
</span><span class="inferred1"><a name="line610" />610 
</span><span class="inferred0"><a name="line611" />611     # Test patterns =~ support
</span><span class="marked1"><a name="line612" />612     def test_patterns_3
</span><span class="marked0"><a name="line613" />613         a = XML.parse &quot;&lt;foo&gt;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;, &lt;bar color='red'&gt;world&lt;/bar&gt;&lt;excl&gt;!&lt;/excl&gt;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line614" />614         a.normalize!
</span><span class="inferred0"><a name="line615" />615         
</span><span class="marked1"><a name="line616" />616         blue    = []
</span><span class="marked0"><a name="line617" />617         nocolor = []
</span><span class="marked1"><a name="line618" />618         bar     = []
</span><span class="marked0"><a name="line619" />619         hello   = []
</span><span class="inferred1"><a name="line620" />620         
</span><span class="marked0"><a name="line621" />621         a.descendants {|d|
</span><span class="marked1"><a name="line622" />622             if d =~ :bar
</span><span class="marked0"><a name="line623" />623                 bar &lt;&lt; d
</span><span class="inferred1"><a name="line624" />624             end
</span><span class="inferred0"><a name="line625" />625 
</span><span class="marked1"><a name="line626" />626             if d =~ {:color =&gt; 'blue'}
</span><span class="marked0"><a name="line627" />627                 blue &lt;&lt; d
</span><span class="inferred1"><a name="line628" />628             end
</span><span class="inferred0"><a name="line629" />629         
</span><span class="marked1"><a name="line630" />630             if d =~ {:color =&gt; nil}
</span><span class="marked0"><a name="line631" />631                 nocolor &lt;&lt; d
</span><span class="inferred1"><a name="line632" />632             end
</span><span class="inferred0"><a name="line633" />633         
</span><span class="marked1"><a name="line634" />634             if d =~ /Hello/
</span><span class="marked0"><a name="line635" />635                 hello &lt;&lt; d
</span><span class="inferred1"><a name="line636" />636             end
</span><span class="inferred0"><a name="line637" />637         }
</span><span class="inferred1"><a name="line638" />638         
</span><span class="marked0"><a name="line639" />639         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), XML.parse(&quot;&lt;bar color='red'&gt;world&lt;/bar&gt;&quot;)], bar, &quot;Pattern matching should work&quot;)
</span><span class="marked1"><a name="line640" />640         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;)], blue, &quot;Pattern matching should work&quot;)
</span><span class="marked0"><a name="line641" />641         assert_equal([XML.parse(&quot;&lt;excl&gt;!&lt;/excl&gt;&quot;)], nocolor, &quot;Pattern matching should work&quot;)
</span><span class="marked1"><a name="line642" />642         assert_equal([XML.parse(&quot;&lt;bar color='blue'&gt;Hello&lt;/bar&gt;&quot;), &quot;Hello&quot;], hello, &quot;Pattern matching should work&quot;)
</span><span class="inferred0"><a name="line643" />643     end
</span><span class="inferred1"><a name="line644" />644 
</span><span class="marked0"><a name="line645" />645     def test_patterns_any_all
</span><span class="marked1"><a name="line646" />646         a = XML.parse &quot;&lt;foo&gt;
</span><span class="inferred0"><a name="line647" />647         &lt;bar color='blue' size='big'&gt;1&lt;/bar&gt;
</span><span class="inferred1"><a name="line648" />648         &lt;bar color='blue'&gt;2&lt;/bar&gt;
</span><span class="inferred0"><a name="line649" />649         &lt;bar color='blue' size='normal'&gt;3&lt;/bar&gt;
</span><span class="inferred1"><a name="line650" />650         &lt;bar color='red' size='big'&gt;4&lt;/bar&gt;
</span><span class="inferred0"><a name="line651" />651         &lt;bar color='red'&gt;5&lt;/bar&gt;
</span><span class="inferred1"><a name="line652" />652         &lt;bar color='red' size='normal'&gt;6&lt;/bar&gt;
</span><span class="inferred0"><a name="line653" />653         &lt;/foo&gt;&quot;
</span><span class="inferred1"><a name="line654" />654         
</span><span class="marked0"><a name="line655" />655         p = all({:color =&gt; 'red'}, any({:size =&gt; nil}, {:size =&gt; 'normal'}))
</span><span class="inferred1"><a name="line656" />656         # Select childern which color red and size either normal or not specified
</span><span class="marked0"><a name="line657" />657         b = a.children(p)
</span><span class="marked1"><a name="line658" />658         c = a.find_all{|x| x =~ p }
</span><span class="marked0"><a name="line659" />659         d = a.find_all{|x| p === x }
</span><span class="inferred1"><a name="line660" />660         
</span><span class="marked0"><a name="line661" />661         assert_equal(&quot;&lt;bar color='red'&gt;5&lt;/bar&gt;&lt;bar color='red' size='normal'&gt;6&lt;/bar&gt;&quot;, b.to_s, &quot;Pattern matching with any/all should work&quot;)
</span><span class="marked1"><a name="line662" />662         assert_equal(&quot;&lt;bar color='red'&gt;5&lt;/bar&gt;&lt;bar color='red' size='normal'&gt;6&lt;/bar&gt;&quot;, c.to_s, &quot;Pattern matching with any/all should work&quot;)
</span><span class="marked0"><a name="line663" />663         assert_equal(&quot;&lt;bar color='red'&gt;5&lt;/bar&gt;&lt;bar color='red' size='normal'&gt;6&lt;/bar&gt;&quot;, d.to_s, &quot;Pattern matching with any/all should work&quot;)
</span><span class="inferred1"><a name="line664" />664     end
</span><span class="inferred0"><a name="line665" />665 
</span><span class="inferred1"><a name="line666" />666     # Test parse option :ignore_pretty_printing
</span><span class="marked0"><a name="line667" />667     def test_remove_pretty_printing
</span><span class="marked1"><a name="line668" />668         a = &quot;&lt;foo&gt;&lt;bar&gt;100&lt;/bar&gt;&lt;bar&gt;200&lt;/bar&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line669" />669         b = &quot;&lt;foo&gt;
</span><span class="inferred1"><a name="line670" />670                &lt;bar&gt;
</span><span class="inferred0"><a name="line671" />671                  100
</span><span class="uncovered1"><a name="line672" />672                &lt;/bar&gt;
</span><span class="uncovered0"><a name="line673" />673                &lt;bar&gt;
</span><span class="uncovered1"><a name="line674" />674                  200
</span><span class="uncovered0"><a name="line675" />675                &lt;/bar&gt;
</span><span class="uncovered1"><a name="line676" />676              &lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line677" />677          c = XML.parse(a)
</span><span class="marked1"><a name="line678" />678          d = XML.parse(b)
</span><span class="marked0"><a name="line679" />679          e = XML.parse(b)
</span><span class="marked1"><a name="line680" />680          e.remove_pretty_printing!
</span><span class="inferred0"><a name="line681" />681          
</span><span class="marked1"><a name="line682" />682          assert_not_equal(c.to_s, d.to_s, &quot;XML#parse should not ignore pretty printing by default&quot;)
</span><span class="marked0"><a name="line683" />683          assert_equal(c.to_s, e.to_s, &quot;XML#remove_pretty_printing! should work&quot;)
</span><span class="inferred1"><a name="line684" />684          
</span><span class="marked0"><a name="line685" />685          f = XML.parse(&quot;&lt;foo&gt; &lt;bar&gt;Hello    world&lt;/bar&gt; &lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line686" />686          f.remove_pretty_printing!
</span><span class="marked0"><a name="line687" />687          g = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;Hello world&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line688" />688          assert_equal(f.to_s, g.to_s, &quot;XML#remove_pretty_printing! should work&quot;)
</span><span class="inferred0"><a name="line689" />689     end
</span><span class="inferred1"><a name="line690" />690 
</span><span class="inferred0"><a name="line691" />691     # Test remove_pretty_printing! with exception list
</span><span class="marked1"><a name="line692" />692     def test_remove_pretty_printing_conditional
</span><span class="marked0"><a name="line693" />693         a = &quot;&lt;foo&gt;
</span><span class="inferred1"><a name="line694" />694                &lt;pre&gt;
</span><span class="inferred0"><a name="line695" />695                  &lt;a&gt; 100 &lt;/a&gt;
</span><span class="inferred1"><a name="line696" />696                &lt;/pre&gt;
</span><span class="inferred0"><a name="line697" />697                &lt;xyzzy&gt;
</span><span class="inferred1"><a name="line698" />698                  &lt;a&gt; 200 &lt;/a&gt;
</span><span class="inferred0"><a name="line699" />699                &lt;/xyzzy&gt;
</span><span class="inferred1"><a name="line700" />700              &lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line701" />701         b = &quot;&lt;foo&gt;&lt;pre&gt;
</span><span class="inferred1"><a name="line702" />702                  &lt;a&gt; 100 &lt;/a&gt;
</span><span class="inferred0"><a name="line703" />703                &lt;/pre&gt;&lt;xyzzy&gt;&lt;a&gt;200&lt;/a&gt;&lt;/xyzzy&gt;&lt;/foo&gt;&quot;
</span><span class="inferred1"><a name="line704" />704 
</span><span class="marked0"><a name="line705" />705         ax = XML.parse(a)
</span><span class="marked1"><a name="line706" />706         bx = XML.parse(b)
</span><span class="inferred0"><a name="line707" />707         
</span><span class="marked1"><a name="line708" />708         ax.remove_pretty_printing!([:pre])
</span><span class="inferred0"><a name="line709" />709 
</span><span class="marked1"><a name="line710" />710         assert_equal(bx.to_s, ax.to_s, &quot;XML#remove_pretty_printing!(exceptions) should work&quot;)
</span><span class="inferred0"><a name="line711" />711     end
</span><span class="inferred1"><a name="line712" />712     
</span><span class="inferred0"><a name="line713" />713     # Test extra arguments to XML#parse - :comments and :pi
</span><span class="marked1"><a name="line714" />714     def test_parsing_extras
</span><span class="marked0"><a name="line715" />715         a = &quot;&lt;foo&gt;&lt;?xml-stylesheet href='http://www.blogger.com/styles/atom.css' type='text/css'?&gt;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line716" />716         b = &quot;&lt;foo&gt;&lt;!-- This is a comment --&gt;&lt;/foo&gt;&quot;
</span><span class="inferred0"><a name="line717" />717         
</span><span class="marked1"><a name="line718" />718         ax = XML.parse(a)
</span><span class="marked0"><a name="line719" />719         bx = XML.parse(b)
</span><span class="inferred1"><a name="line720" />720         
</span><span class="marked0"><a name="line721" />721         assert_equal(&quot;&lt;foo/&gt;&quot;, ax.to_s, &quot;XML#parse should drop PI by default&quot;)
</span><span class="marked1"><a name="line722" />722         assert_equal(&quot;&lt;foo/&gt;&quot;, bx.to_s, &quot;XML#parse should drop comments by default&quot;)
</span><span class="inferred0"><a name="line723" />723         
</span><span class="marked1"><a name="line724" />724         ay = XML.parse(a, :comments =&gt; true, :pi =&gt; true)
</span><span class="marked0"><a name="line725" />725         by = XML.parse(b, :comments =&gt; true, :pi =&gt; true)
</span><span class="inferred1"><a name="line726" />726 
</span><span class="marked0"><a name="line727" />727         assert_equal(a, ay.to_s, &quot;XML#parse(str, :pi=&gt;true) should include PI&quot;)
</span><span class="marked1"><a name="line728" />728         assert_equal(b, by.to_s, &quot;XML#parse(str, :comments=&gt;true) should include comments&quot;)
</span><span class="inferred0"><a name="line729" />729     end
</span><span class="inferred1"><a name="line730" />730     
</span><span class="inferred0"><a name="line731" />731     # Test extra arguments to XML#parse - :remove_pretty_printing.
</span><span class="inferred1"><a name="line732" />732     # FIXME: How about a shorter (but still mnemonic) name for that ?
</span><span class="marked0"><a name="line733" />733     def test_parsing_nopp
</span><span class="marked1"><a name="line734" />734         a = &quot;&lt;foo&gt;&lt;bar&gt;100&lt;/bar&gt;&lt;bar&gt;200&lt;/bar&gt;&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line735" />735         b = &quot;&lt;foo&gt;
</span><span class="inferred1"><a name="line736" />736                &lt;bar&gt;
</span><span class="inferred0"><a name="line737" />737                  100
</span><span class="uncovered1"><a name="line738" />738                &lt;/bar&gt;
</span><span class="uncovered0"><a name="line739" />739                &lt;bar&gt;
</span><span class="uncovered1"><a name="line740" />740                  200
</span><span class="uncovered0"><a name="line741" />741                &lt;/bar&gt;
</span><span class="uncovered1"><a name="line742" />742              &lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line743" />743         c = XML.parse(a)
</span><span class="marked1"><a name="line744" />744         d = XML.parse(b)
</span><span class="marked0"><a name="line745" />745         e = XML.parse(b, :remove_pretty_printing =&gt; true)
</span><span class="inferred1"><a name="line746" />746 
</span><span class="marked0"><a name="line747" />747         assert_not_equal(c.to_s, d.to_s, &quot;XML#parse should not ignore pretty printing by default&quot;)
</span><span class="marked1"><a name="line748" />748         assert_equal(c.to_s, e.to_s, &quot;XML#parse(str, :remove_pretty_printing=&gt;true) should work&quot;)
</span><span class="inferred0"><a name="line749" />749     end
</span><span class="inferred1"><a name="line750" />750     
</span><span class="inferred0"><a name="line751" />751     # Test XML.parse(str, :extra_entities =&gt; ...)
</span><span class="marked1"><a name="line752" />752     def test_parsing_entities
</span><span class="marked0"><a name="line753" />753         a = &quot;&lt;foo&gt;&amp;cat; &amp;amp; &amp;dog;&lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line754" />754         b = XML.parse(a, :extra_entities =&gt; lambda{|e|
</span><span class="marked0"><a name="line755" />755             case e
</span><span class="marked1"><a name="line756" />756             when &quot;cat&quot;
</span><span class="marked0"><a name="line757" />757                 &quot;neko&quot;
</span><span class="marked1"><a name="line758" />758             when &quot;dog&quot;
</span><span class="marked0"><a name="line759" />759                  &quot;inu&quot;
</span><span class="inferred1"><a name="line760" />760             end
</span><span class="inferred0"><a name="line761" />761         })
</span><span class="marked1"><a name="line762" />762         c = XML.parse(a, :extra_entities =&gt; {&quot;cat&quot; =&gt; &quot;neko&quot;, &quot;dog&quot; =&gt; &quot;inu&quot;})
</span><span class="inferred0"><a name="line763" />763         
</span><span class="marked1"><a name="line764" />764         assert_equal(&quot;neko &amp; inu&quot;, b.text, &quot;XML#parse(str, :extra_entities=&gt;Proc) should work&quot;)
</span><span class="marked0"><a name="line765" />765         assert_equal(&quot;neko &amp; inu&quot;, c.text, &quot;XML#parse(str, :extra_entities=&gt;Hash) should work&quot;)
</span><span class="inferred1"><a name="line766" />766         
</span><span class="marked0"><a name="line767" />767         d = XML.parse(a, :extra_entities =&gt; {&quot;cat&quot; =&gt; &quot;neko&quot;, &quot;dog&quot; =&gt; &quot;inu&quot;})
</span><span class="inferred1"><a name="line768" />768         
</span><span class="inferred0"><a name="line769" />769         # Central European characters escapes
</span><span class="marked1"><a name="line770" />770         e = &quot;&lt;foo&gt;&amp;zdot;&amp;oacute;&amp;lstrok;w&lt;/foo&gt;&quot;
</span><span class="marked0"><a name="line771" />771         f = XML.parse(e, :extra_entities =&gt; {&quot;zdot&quot; =&gt; 380, &quot;oacute&quot; =&gt; 243, &quot;lstrok&quot; =&gt; 322})
</span><span class="inferred1"><a name="line772" />772         
</span><span class="inferred0"><a name="line773" />773         # Assumes \number does bytes, UTF8
</span><span class="marked1"><a name="line774" />774         assert_equal(&quot;\305\274\303\263\305\202w&quot;, f.text, &quot;XML#parse(str, :extra_entities=&gt;...) should work with integer codepoints&quot;)
</span><span class="inferred0"><a name="line775" />775     end
</span><span class="inferred1"><a name="line776" />776     
</span><span class="inferred0"><a name="line777" />777     # Test XML.load
</span><span class="marked1"><a name="line778" />778     def test_load
</span><span class="marked0"><a name="line779" />779         a = XML.load(&quot;test.xml&quot;)
</span><span class="marked1"><a name="line780" />780         b = XML.load(File.open(&quot;test.xml&quot;))
</span><span class="marked0"><a name="line781" />781         c = XML.load(&quot;string:&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line782" />782         d = XML.load(&quot;file:test.xml&quot;)
</span><span class="inferred0"><a name="line783" />783         
</span><span class="marked1"><a name="line784" />784         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;, a.to_s, &quot;XML#load should work&quot;)
</span><span class="marked0"><a name="line785" />785         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;, b.to_s, &quot;XML#load should work&quot;)
</span><span class="marked1"><a name="line786" />786         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;, c.to_s, &quot;XML#load should work&quot;)
</span><span class="marked0"><a name="line787" />787         assert_equal(&quot;&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;&quot;, d.to_s, &quot;XML#load should work&quot;)
</span><span class="inferred1"><a name="line788" />788     end
</span><span class="inferred0"><a name="line789" />789     
</span><span class="inferred1"><a name="line790" />790     # Test multielement selectors
</span><span class="marked0"><a name="line791" />791     def test_multielement_selectors
</span><span class="marked1"><a name="line792" />792         a = XML.parse(&quot;&lt;foo&gt;&lt;bar color='blue'&gt;&lt;x/&gt;&lt;/bar&gt;&lt;bar color='red'&gt;&lt;x&gt;&lt;y i='1'/&gt;&lt;/x&gt;&lt;y i='2'/&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line793" />793         assert_equal(&quot;&lt;x/&gt;&lt;x&gt;&lt;y i='1'/&gt;&lt;/x&gt;&quot;, a.children(:bar, :x).to_s, &quot;Multielement selectors should work&quot;)
</span><span class="marked1"><a name="line794" />794         assert_equal(&quot;&lt;y i='2'/&gt;&quot;, a.children(:bar, :y).to_s, &quot;Multielement selectors should work&quot;)
</span><span class="marked0"><a name="line795" />795         assert_equal(&quot;&lt;y i='1'/&gt;&lt;y i='2'/&gt;&quot;, a.children(:bar, :*, :y).to_s, &quot;Multielement selectors should work&quot;)
</span><span class="marked1"><a name="line796" />796         assert_equal(&quot;&lt;y i='1'/&gt;&quot;, a.descendants(:x, :y).to_s, &quot;Multielement selectors should work&quot;)
</span><span class="marked0"><a name="line797" />797         assert_equal(&quot;&lt;y i='1'/&gt;&lt;y i='2'/&gt;&quot;, a.children(:bar, :*, :y).to_s, &quot;Multielement selectors should work&quot;)
</span><span class="inferred1"><a name="line798" />798     end
</span><span class="inferred0"><a name="line799" />799     
</span><span class="inferred1"><a name="line800" />800     # Test deep_map
</span><span class="marked0"><a name="line801" />801     def test_deep_map
</span><span class="marked1"><a name="line802" />802         a = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;x&lt;/bar&gt; &lt;foo&gt;&lt;bar&gt;y&lt;/bar&gt;&lt;/foo&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line803" />803         b = a.deep_map(:bar) {|c| XML.new(c.text.to_sym) }
</span><span class="marked1"><a name="line804" />804         assert_equal(&quot;&lt;foo&gt;&lt;x/&gt; &lt;foo&gt;&lt;y/&gt;&lt;/foo&gt;&lt;/foo&gt;&quot;, b.to_s, &quot;XML#deep_map should work&quot;)
</span><span class="inferred0"><a name="line805" />805 
</span><span class="marked1"><a name="line806" />806         c = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;x&lt;/bar&gt; &lt;bar&gt;&lt;bar&gt;y&lt;/bar&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked0"><a name="line807" />807         d = c.deep_map(:bar) {|c| XML.new(:xyz, c.attrs, *c.children) }
</span><span class="marked1"><a name="line808" />808         assert_equal(&quot;&lt;foo&gt;&lt;xyz&gt;x&lt;/xyz&gt; &lt;xyz&gt;&lt;bar&gt;y&lt;/bar&gt;&lt;/xyz&gt;&lt;/foo&gt;&quot;, d.to_s, &quot;XML#deep_map should work&quot;)
</span><span class="inferred0"><a name="line809" />809     end
</span><span class="inferred1"><a name="line810" />810 
</span><span class="inferred0"><a name="line811" />811     # Test XML.load
</span><span class="marked1"><a name="line812" />812     def test_pretty_printer
</span><span class="marked0"><a name="line813" />813         a = XML.parse(&quot;&lt;foo&gt;&lt;bar&gt;x&lt;/bar&gt;Boo!&lt;bar&gt;&lt;y&gt;&lt;z&gt;f&lt;/z&gt;&lt;/y&gt;&lt;/bar&gt;&lt;xyzzy /&gt;&lt;bar&gt;Mutiline\nText\n:-)&lt;/bar&gt;&lt;/foo&gt;&quot;)
</span><span class="marked1"><a name="line814" />814         a.add_pretty_printing!
</span><span class="marked0"><a name="line815" />815         expected = &quot;&lt;foo&gt;
</span><span class="inferred1"><a name="line816" />816   &lt;bar&gt;
</span><span class="inferred0"><a name="line817" />817     x
</span><span class="uncovered1"><a name="line818" />818   &lt;/bar&gt;
</span><span class="uncovered0"><a name="line819" />819   Boo!
</span><span class="uncovered1"><a name="line820" />820   &lt;bar&gt;
</span><span class="uncovered0"><a name="line821" />821     &lt;y&gt;
</span><span class="uncovered1"><a name="line822" />822       &lt;z&gt;
</span><span class="uncovered0"><a name="line823" />823         f
</span><span class="uncovered1"><a name="line824" />824       &lt;/z&gt;
</span><span class="uncovered0"><a name="line825" />825     &lt;/y&gt;
</span><span class="uncovered1"><a name="line826" />826   &lt;/bar&gt;
</span><span class="uncovered0"><a name="line827" />827   &lt;xyzzy/&gt;
</span><span class="uncovered1"><a name="line828" />828   &lt;bar&gt;
</span><span class="uncovered0"><a name="line829" />829     Mutiline
</span><span class="uncovered1"><a name="line830" />830     Text
</span><span class="uncovered0"><a name="line831" />831     :-)
</span><span class="uncovered1"><a name="line832" />832   &lt;/bar&gt;
</span><span class="uncovered0"><a name="line833" />833 &lt;/foo&gt;&quot;
</span><span class="marked1"><a name="line834" />834         assert_equal(expected, a.to_s, &quot;XML#pretty_print! should work&quot;)
</span><span class="inferred0"><a name="line835" />835     end
</span><span class="inferred1"><a name="line836" />836 end
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.0.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
